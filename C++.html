<!DOCTYPE html>
<html lang="en">
<head>
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css">
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
    <link rel="stylesheet" href="C++.css">
</head>
<body>
<script src="https://cdn.jsdelivr.net/gh/google/code-prettify@master/loader/run_prettify.js"></script>

    <div class="nav">
        <input type="checkbox" id="nav-check">
        <div class="nav-header">
          <div class="nav-title">
            OneLinerNotes
          </div>
        </div>
        <div class="nav-btn">
          <label for="nav-check">
            <span></span>
            <span></span>
            <span></span>
          </label>
        </div>
        
        <div class="nav-links">
            <ul>
          <li><a href="#" target="_blank">Home</a></li>
          <li><a href="#" target="_blank">HTML</a></li>
          <li><a href="#" target="_blank">CSS</a></li>
          <li><a href="#" target="_blank">Javascript</a></li>
          <li><a href="#" target="_blank">C++</a></li>
          <li><a href="#" target="_blank">Mcqs</a></li>
          <a class="icon">
            <i class="fa fa-twitter"></i>
            <i class="fa fa-linkedin"></i>
            <i class="fa fa-youtube"></i>

          </a>
            </ul>
        </div>
      </div><br><br><br>

<div class="container">
 <div class="links">
 
	<h3>Programming Paradigm:</h3>
<p>It is the methods which we use to solve problem or to do some task.<strong>A programming paradigm is a way, an approach, a style by which we write programs in a specific programming language to solve some problem.</strong> 
You may be thinking what style or approach are we talking about. It is the approach creation of objects and creating programs in object oriented programming or solving problems with series of functions in functional programming or a style of creation of logic by series of symbols in logic programming.<br><br>
<strong>Programming paradigms</strong> are approaches used to categorize or classify programming languages based on techniques and features they support. <br><br>

For example:<br>

1)Object-oriented programming is best suited for implementing real-world entities by hiding important data and finding methods with the entities. Example C++, Java, Python, etc.<br>

2)Logical programming is best for creating logic by a complex structure of symbols. Example Prolog, F-logic, etc.<br><br>

A good programming language should support multiple paradigms because different programming problems require a different way to approach. If a programing language support only one or two paradigms then it may not be sufficient or contains feature required. <br><br>

Most modern languages support are multi-paradigm languages like C++, C#, Python, Go, etc. <br><br>

<h3>Types Of Programming Paradigms:</h3>
<img src="images/Prog.png" alt="error"/><br><br>
1)Imperative Programming Paradigm.<br><br>
2)Declarative Programming Paradigm.<br><br>
<h3>Understanding Imperative and Declarative:</h3>
Let’s Take a simple Example,In C++ Language you learn about stack data structure, and also implemented each function of stack data structure step by step, like for push operation you declare and provide implementation of a push function , for pop operation  you declare and provide implementation of a pop function .<br><br>

So, we learn stack data structure by first implementing every stack functions and understanding their functioning step by step.This approach is known as Imperative Programming Paradigm in this the code describes a step-by-step process for a program’s execution. Because of this, beginners often find it easier to reason with imperative code by following along with the steps in the process.<br><br>
The step-by-step process contains individual statements, instructions, or function calls. In the programming world, this process is called the control flow.<br><br>

On the other hand, you also learned about header files in C/C++ language,for stack data structure we already have a header file in C++  and we include it as  #include&lt;stack&gt;,this header file already have the implementation of the stack functions so when you are including stack header file you need not to provide implementation of stack functions you can just directly use them by calling and passing some value to them.  This is declarative Programming Paradigm, in this we only concern about the result we want and use the already implemented functions according to our use to get our desired output.<br><br>
Example:1

<pre>
<code>
//1) *Imperative approach to implement stack using arrays in C++
#include &lt;iostream&gt;
using namespace std;
int stack[100], n=100, top=-1;
void push(int val) {
   if(top&gt;=n-1)
   cout&lt;&lt;&quot;Stack Overflow&quot;&lt;&lt;endl;
   else {
      top++;
      stack[top]=val;
   }
}
void pop() {
   if(top&lt;=-1)
   cout&lt;&lt;&quot;Stack Underflow&quot;&lt;&lt;endl;
   else {
      cout&lt;&lt;&quot;The popped element is &quot;&lt;&lt; stack[top] &lt;&lt;endl;
      top--;
   }
}
void display() {
   if(top&gt;=0) {
      cout&lt;&lt;&quot;Stack elements are:&quot;;
      for(int i=top; i&gt;=0; i--)
      cout&lt;&lt;stack[i]&lt;&lt;&quot; &quot;;
      cout&lt;&lt;endl;
   } else
   cout&lt;&lt;&quot;Stack is empty&quot;;
}
int main() {
   int ch, val;
   cout&lt;&lt;&quot;1) Push in stack&quot;&lt;&lt;endl;
   cout&lt;&lt;&quot;2) Pop from stack&quot;&lt;&lt;endl;
   cout&lt;&lt;&quot;3) Display stack&quot;&lt;&lt;endl;
   cout&lt;&lt;&quot;4) Exit&quot;&lt;&lt;endl;
   do {
      cout&lt;&lt;&quot;Enter choice: &quot;&lt;&lt;endl;
      cin&gt;&gt;ch;
      switch(ch) {
         case 1: {
            cout&lt;&lt;&quot;Enter value to be pushed:&quot;&lt;&lt;endl;
            cin&gt;&gt;val;
            push(val);
            break;
         }
         case 2: {
            pop();
            break;
         }
         case 3: {
            display();
            break;
         }
         case 4: {
            cout&lt;&lt;&quot;Exit&quot;&lt;&lt;endl;
            break;
         }
         default: {
            cout&lt;&lt;&quot;Invalid Choice&quot;&lt;&lt;endl;
         }
      }
   }while(ch!=4);
   return 0;
}
 

</code>

</pre>

Now, Converting the imperative approach to declarative approach.
ex:
<pre>
<code>
//Declarative Approach using stack data structure.
#include &lt;iostream&gt;
#include &lt;stack&gt;

using namespace std;

class stack1
{
    stack&lt;int&gt; st;
	public: 
	
	void isemt()
	{
		if(st.empty())
			cout&lt;&lt;&quot;Stack is empty&quot;&lt;&lt;endl;
		else
			cout&lt;&lt;&quot;Stack is not empty&quot;&lt;&lt;endl;
	}
	
	void stksize()
	{
		
		cout&lt;&lt;&quot;Size of stack is:&quot;&lt;&lt;st.size()&lt;&lt;endl;	
	}
	
    void stkpush(int val) 
	{
   		st.push(val);
	}
	void stkpop() 
	{
	    st.pop();
      	cout&lt;&lt;&quot;The element is popped &quot;&lt;&lt;endl;
	}	

 	void display() 
	{
   		while (!st.empty())
		{
			cout &lt;&lt; ' ' &lt;&lt; st.top();
			st.pop();
		}
         cout &lt;&lt; endl;
	}	
};

int main() {
	
   stack1 stk;
   int ch, val;
   cout&lt;&lt;&quot;1) Push in stack&quot;&lt;&lt;endl;
   cout&lt;&lt;&quot;2) Pop from stack&quot;&lt;&lt;endl;
   cout&lt;&lt;&quot;3) Display stack&quot;&lt;&lt;endl;
   cout&lt;&lt;&quot;4) Check stack is empty or not&quot;&lt;&lt;endl;
   cout&lt;&lt;&quot;5) Size of stack&quot;&lt;&lt;endl;
   cout&lt;&lt;&quot;6) Exit&quot;&lt;&lt;endl;
   do {
      cout&lt;&lt;&quot;Enter choice: &quot;&lt;&lt;endl;
      cin&gt;&gt;ch;
      switch(ch) {
         case 1: {
            cout&lt;&lt;&quot;Enter value to be pushed:&quot;&lt;&lt;endl;
            cin&gt;&gt;val;
            stk.stkpush(val);
            break;
         }
         case 2: {
            stk.stkpop();
            break;
         }
         case 3: {
            stk.display();
            break;
         }
         case 4: {
            stk.isemt();
            break;
         }
         case 5: {
            stk.stksize();
            break;
         }
         case 6: {
            cout&lt;&lt;&quot;Exit&quot;&lt;&lt;endl;
            break;
         }
         default: {
            cout&lt;&lt;&quot;Invalid Choice&quot;&lt;&lt;endl;
         }
      }
   }while(ch!=6);
   return 0;
}

</code>
</pre>
You must be confused many of you haven’t read that big codes, so here is an simple example.<br><br>
<strong>Q:C++ Program to raise x to the power of y.</strong><br>
<strong>1.Imperative Approach.</strong><br>
<pre>
<code>
#include
using namespace std;

int main(){
   int x, y, ans = 1;

   cout &lt;&lt; &quot;Enter the base value: n&quot;;
   cin &gt;&gt; x;

   cout &lt;&lt; &quot;Enter the exponent value: n&quot;;
   cin &gt;&gt; y;

   for(int i=0; i&lt;y; i++)
   ans *= x;

   cout &lt;&lt; x &lt;&lt;&quot; raised to the power &quot;&lt;&lt; y &lt;&lt;&quot; is &quot;&lt;&amp;;lt;ans;

   return 0;
}

</code>
</pre>

<strong>2.Declarative Approach.</strong><br>
<pre>
<code>
#include &lt;iostream&gt;
#include &lt;cmath&gt;
using namespace std;
int main() 
{
    float base, exponent, result;

    cout &lt;&lt; &quot;Enter base and exponent respectively:  &quot;;
    cin &gt;&gt; base &gt;&gt; exponent;

    result = pow(base, exponent);

    cout &lt;&lt; base &lt;&lt; &quot;^&quot; &lt;&lt; exponent &lt;&lt; &quot; = &quot; &lt;&lt; result;
    
    return 0;
}

</code>
</pre>
Now i hope that the meaning of imperative and declarative is clear to you guys!!!.<br><br>

Languages which can be use both paradigm are :<br>
<strong>Python</strong>- supports both imperative and declarative programming paradigm with the concept of python libraries and modules.<br>
<strong>Java</strong>- Supports both imperatve and declarative programming paradigm with introduction of collections framework.<br>
<strong>C++</strong> - Supports both imperative and declarative programming paradigm with introduction of STL(Standard Template Library) which introduced in its newer version.<br>
<br><br>
<table>
<tr><th>Imperative programming paradigm(how to do)</th><th>Declarative programming paradigm(what to do)</th></tr>
<tr><td>You describe the step-by-step instructions for how an executed program achieves the desired results.</td><td>You set the conditions that trigger the program execution to produce the desired results. </td></tr>
<tr><td>With the emphasis on the control flow, you can often follow the step-by-step process fairly easily. However, as you add more features and code to your program, it can become longer and more complex, making it increasingly confusing and time-consuming to read.
</td><td>This paradigm is less complex and requires less code, making it easier to read.</td></tr>
<tr><td>Cutomizing the source code is easierCustomizing the source code is more difficult because of complicated syntax and the paradigm’s dependence on implementing a pre-configured algorithm.</td><td>Customizing the source code is difficult.Customizing the source code is more difficult because of complicated syntax and the paradigm’s dependence on implementing a pre-configured algorithm. </td></tr>
<tr><td>Its main goal is to describe how to get it or accomplish it. </td><td>Its main goal is to describe the desired result without direct dictation on how to get it.  </td></tr>
<tr><td>C,C++,Java,Python follows imperative programming.</td><td>Domain Specific ex: HTML,SQL,CSS,XML follows declarative Programming.</td></tr>
</table>
<h3>Types of Imperative Paradigms.</h3>
<h3>1.1)Procedural Programming Language</h3>
 Procedural Programming Language is same as Imperative approach of Programming in which you define implementation which a system follow step by steps to complete a task. 

 In this you use Procedures, Sub routines, Functions you implement it and call it wherever you need it.
 
  User has to specify  “what to do”  and also  “how to do”(step by step procedure). These instructions are executed in the sequential order.
  <br><br>
  <h3>1.2)Object Oriented Programming Language</h3>
Object-oriented programming, or OOP, is an approach to problem solving where all computations are carried out using objects. An object is a component of a program that knows how to perform certain actions and how to interact with other elements of the program. Objects are the basic units of object-oriented programming. A simple example of an object would be a person. Logically, you would expect a person to have a name. This would be considered a property of the person. You could also expect a person to be able to do something, such as walking or driving. This would be considered a method of the person.
<br><br>
Code in object-oriented programming is organized around objects. Once you have your objects, they can interact with each other to make something happen. Let's say you want to have a program where a person gets into a car and drives it from A to B. You would start by describing the objects, such as a person and car. That includes methods: a person knows how to drive a car, and a car knows what it is like to be driven. Once you have your objects, you bring them together so the person can get into the car and drive.
<br><br>
<strong>Classes and Objects</strong>
A class is a blueprint of an object. You can think of a class as a concept, and the object is the embodiment of that concept. You need to have a class before you can create an object. So, let's say you want to use a person in your program. You want to be able to describe the person and have the person do something. A class called 'person' would provide a blueprint for what a person looks like and what a person can do. To actually use a person in your program, you need to create an object. You use the person class to create an object of the type 'person.' Now you can describe this person and have it do something.
<br>
Classes are very useful in programming. Consider the example of where you don't want to use just one person but 100 people. Rather than describing each one in detail from scratch, you can use the same person class to create 100 objects of the type 'person.' You still have to give each one a name and other properties, but the basic structure of what a person looks like is the same.
<br><br>
<h3>1.3)Structured Programming Languages</h3>
In the process of coding,the lines of code keep multiplying,thus,size of the software increases. Gradually, it becomes next to impossible to remember the flow of program. if one forgets how software and its underlying programs,files,procedures are constructed, it then becomes very difficult to share ,debug, and modify the program. The solution to this is structured programming. It encourages the developer to use subroutines and loops instead of using simple jumps in the code, thereby bringing clarity in the code and improving its efficiency Structured Programming also helps programmer to reduce coding time and organize code properly.

<br><br>
<h3>Types of Declarative Paradigms</h3>
<h3>2.1)Logical Programming</h3>
Logic programming is a programming paradigm that is based on logic. This means logic programming languages have statements that follow logic by expressing facts and rules.<br>
An algorithm is a logical programming paradigm that is a combination of a control component and a logic component. A program is usually broken down into these two components. While the control component is optional, the logic component is the essence of the algorithm.

In purely logic-based programs (i.e., the programs that do not use control components), the logic component alone decides the solution. In a program where both the components are employed, the control component determines the ways by which the solution is produced.

<h3>2.2)Functional Programming</h3>
 FP is a style of programming in which the main program building blocks are functions as opposed to objects and procedures. A program written in the functional style doesn’t specify the commands that should be performed to achieve the result, but rather defines what the result is.

Consider a small example: calculating the sum of a list of numbers. In the imperative world, you implement this by iterating over the list and adding the numbers to the accumulator variable. You explain the step-by-step process of how to sum a list of numbers. On the other hand, in the functional style, you need to define only what a sum of a list of numbers is. The computer knows what to do when it’s required to calculate a sum. One way you can do this is to say that the sum of a list of numbers equals the first element of the list added to the sum of the rest of the list, and that the sum is zero if the list is empty. You define what the sum is without explaining how to calculate it.
<H3>Difference between Functional Programming and Object Oriented Programming</H3>
<table>
<tr><th>Functional Programming</th><th>Object Oriented Programming</th></tr>
<tr><td>This programming paradigm emphasizes on the use of functions where each function performs a specific task.</td><td>This programming paradigm is based on object oriented concept. Classes are used where instance of objects are created</td></tr>
<tr><td>In Functional programming, recursion is used for iterative data.</td><td>In OOPs, loops are used for iterative data.</td></tr>
<tr><td>The basic elements of functional programming are Variables and Functions.</td><td>The basic elements of object-oriented programming are objects and methods.</td></tr>
<tr><td>Functional programming is used only when there are few things with more operations.</td><td>Object-oriented programming is used when there are many things with few operations.</td></tr>
<tr><td>In functional programming, the main focus of programming is what are we doing</td><td>In object-oriented programming, the main focus of programming is how are we doing.</td></tr>
</table>
<br><br>
<h3>Pillars of Object Oriented Programming</h3>
<h3>1)Abstraction</h3>
Data abstraction means hiding of data.
Abstraction is implemented automatically while writing the code in the form of class and object.
It shows only important things to the user and hides the internal details.
Abstraction (from the Latin abs, meaning away from and trahere , meaning to draw) is the process of taking away or removing characteristics from something in order to reduce it to a set of essential characteristics. Abstraction is related to both encapsulation and data hiding.
he goal of “abstracting” data is to reduce complexity by removing unnecessary information. 
<br>
<b>Realtime Examples of Abstraction:</b>
<br> We all use an ATM machine for cash withdrawal, money transfer, retrieve min-statement, etc in our daily life. But we don’t know internally what things are happening inside ATM machine when you insert an ATM card for performing any kind of operation.
<h4>Example:</h4>
<pre>
	<code>
#include&lt;iostream&gt;
using namespace std;
class Addition
{
    private: int a=10,b=10,c;  // Hidden data from outside world
        public:
            int add()
            {
                 c=a+b;
                 cout&lt;&lt;&quot;Addition is : &quot;&lt;&lt;c;
            }
};
int main()
{
     Addition a;
     a.add();
     return 0;
}
	</code>
</pre>
<b>Output:
Addition is : 20</b><br>

a)In the above example, class Addition adds numbers together and returns the addition or sum. The public member add() function is the interface to the outside world and a user needs to know to use the class. The private member int a,b,c are something that the user does not need to know about, but is needed for the class to operate properly.<br><br>
b)Abstraction provides security for the data from the unauthorized methods and can be achieved by using class<br>
<h3>Abstraction can be achieved in two ways:</h3>
<b>Abstraction using classes:</b> An abstraction can be achieved using classes. A class is used to group all the data members and member functions into a single unit by using the access specifiers. A class has the responsibility to determine which data member is to be visible outside and which is not.

<b>Abstraction in header files:</b> An another type of abstraction is header file. For example, pow() function available is used to calculate the power of a number without actually knowing which algorithm function uses to calculate the power. Thus, we can say that header files hides all the implementation details from the user.

<h3>Access Specifiers Implement Abstraction:</h3>

<b>Public specifier:</b> When the members are declared as public, members can be accessed anywhere from the program.
<b>Private specifier:</b> When the members are declared as private, members can only be accessed only by the member functions of the class.
Let's see a simple example of abstraction in header files.

<br>
Ex: Program to calculate the power of a number.
<pre>
	<code>
#include &lt;iostream&gt;
#include&lt;math.h&gt;
using namespace std;
int main()
{  
 int n = 4;
   int power = 3;
   int result = pow(n,power);         // pow(n,power) is the  power function
   std::cout &lt;&lt; &quot;Cube of n is : &quot; &lt;&lt;result&lt;&lt; std::endl;
   return 0;
}
	</code>
</pre>
<b>Output:
Cube of n is : 64</b>
In the above example, pow() function is used to calculate 4 raised to the power 3. The pow() function is present in the math.h header file in which all the implementation details of the pow() function is hidden.

<b>Let's see a simple example of data abstraction using classes.</b>
<pre>
	<code>
#include &lt;iostream&gt;  
using namespace std;  
 class Sum  
{  
private: int x, y, z; // private variables
public:  
void add()  
{  
cout&lt;&lt;&quot;Enter two numbers: &quot;;  
cin&gt;&gt;x&gt;&gt;y;  
z= x+y;  
cout&lt;&lt;&quot;Sum of two number is: &quot;&lt;&lt;z&lt;&lt;endl;  
}  
};  
int main()  
{  
Sum sm;  
sm.add();  
return 0;  
}  
	</code>
</pre>

<b>Output:

Enter two numbers:
3
6
Sum of two number is: 9</b>
In the above example, abstraction is achieved using classes. A class 'Sum' contains the private members x, y and z are only accessible by the member functions of the class.
<br>
<h3> Advantage of Abstraction:</h3>

 1)Abstraction increases the reusability of the code because of the proper partitioning.<br>
2)It reduces the complexity as well as the redundancy of the code, hence increasing the readability.<br>
3)Using classes and objects increases the security of the code. We can declare the parts of the code as private to keep them secure.<br>
4)Due to abstraction, the important parts of the code are secure as only the essential features are provided to the user and they don’t know the background details.<br>
5)Abstraction allows changing internal implementations without affecting its user-level code.

 <br><br>
 <h3>2)Encapsulation:</h3>
 Encapsulation is one of the important properties of an object-oriented programming language and is defined as wrapping up data and functions into a single unit (e.g. class).<br>

For example, when we create a class and declare variables and functions inside it, we are basically binding them together with the help of the class, thus implementing encapsulation.<br>

But creating a class with properties (attributes) and behaviors (methods) does not always implement encapsulation.

The core concept of encapsulation in OOP is to hide the state (attributes) of an object or class from the outside so that our application is secure and modularised.
<br>
How Exactly can we Implement Encapsulation in OOP?<br>
To implement Encapsulation, we restrict the accessibility of the attributes and make the attributes and functions work together.
One of its most implemented example is the getter and setter of a variable.

We create a private variable and write a getter and setter function for it. In doing so no other class can directly access the variable from outside and it can only be done through getter and setter.

That’s why it is said that encapsulation in a way to implement abstraction.
<h3>Example of Encapsulation in C++</h3>
<pre>
	<code>
#include &lt;iostream&gt;
using namespace std;
 
class Math{
private:
    int sum;   //Can't be accessed from the main method.
    
public:
    //setter for sum
    void add(int a, int b){
        this-&gt;sum = a + b;
    }
    
    //getter for sum
    int getSum(){
        return this-&gt;sum;
    }
};
 
int main()
{
    //Single unit i.e. object of a class
    Math math;
    
    //add two number
    math.add(5,4);
    
    //get the sum using getter method
    cout &lt;&lt; &quot;Sum: &quot;&lt;&lt; math.getSum() &lt;&lt; endl;
    return 0;
}
	</code>
</pre>

<b> Output: Sum:9</b>
<h3>Advantage of encapsulation:</h3>
1)In C++, encapsulation helps to combine the related members into a single class, making the code look cleaner and increasing readability. 
<br>
2)The get() and set() functions provide read-only and write-only accessibility to the user. Hence, keeping the data secure. <br>
3)The bundling of the data eases out the development in general. The testing, debugging, and execution of these bundles can be done individually, which will not affect the other parts. <br>
4)Data hiding is a good way to keep the data secure from the outside world. Hence, improving the security of the code even further. <br>
5)Encapsulation provides us with efficient control of the data as we can alter one part of the code without affecting the other. 

</p>


</div>

<div class="footer">
	  <footer style="background-color:#1177ca; color:white;">
	<div id="foot"> 
<h3>Designed And Developed by Piyush Srivastava</h3> 
<p>
Founder:Piyush Srivastava<br>
Bio:Piyush Srivastava is a A Level Certified Trainer, Trained 100+ Candidates in the field of Web Development and Programming Lanugages,An Open Source Contributer , contributed to 3+ Open source Projects, worked with clients like anythink form Wilco,Intern from IamHere software Lab,Suven Consultants,shine Projects. </p></div> 
<div class="foot">
<div>
<ul>Social Links<hr><br>
<li>LinkedIn</li>
<li>Twitter</li>
<li>Email</li>
<li>Youtube</li>
</ul></div>
<div>
<ul>Courses<hr><br>
<li>HTML</li>
<li>CSS</li>
<li>Javascript</li>
<li>LibreOffice</li>
<li>Java</li>
</ul></div>
<div>
<ul>Roadmaps:<hr><br>
<li>FrontEnd Development</li>
<li>Backend Development</li>
<li>Devops</li>
</ul></div>
<div>
<ul>Jobs<hr><br>
<li>Remote Jobs</li>
<li>Government Jobs</li>
<li>Internships</li>
</ul></div>
</div>

</footer>
</div>
    </div>                    
<script type='text/javascript'>
		(function(I, L, T, i, c, k, s) {if(I.iticks) return;I.iticks = {host:c, settings:s, clientId:k, cdn:L, queue:[]};var h = T.head || T.documentElement;var e = T.createElement(i);var l = I.location;e.async = true;e.src = (L||c)+'/client/inject-v2.min.js';h.insertBefore(e, h.firstChild);I.iticks.call = function(a, b) {I.iticks.queue.push([a, b]);};})(window, 'https://cdn-v1.intelliticks.com/prod/common', document, 'script', 'https://app.intelliticks.com', 'yzXX7ENtB2Q7yZkCa_c', {});
</script>	 
</body>
</html>
